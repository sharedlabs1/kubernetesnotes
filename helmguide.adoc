= Helm Mastery: A Comprehensive Guide
Author:Niranjan Pandey
:toc:

== Introduction

This book is a comprehensive guide to mastering Helm, the package manager for Kubernetes. It covers a wide range of topics from basic Helm deployments to advanced concepts like hooks, subcharts, ArtifactHub customization, monitoring, and Operators. Each lab is designed to provide hands-on experience with practical examples and detailed steps.

== Lab 1: Helm Basics - Creating a Deployment with and without Helm

### Objectives

* Understand the difference between manual Kubernetes deployments and Helm deployments.
* Explore the advantages of using Helm by comparing a manual deployment to one managed by Helm.

### Prerequisites

* A running Kubernetes cluster (Minikube, k3s, or cloud-based).
* Helm installed on your local machine.

### Step 1: Create a Kubernetes Deployment Manually

Create a `deployment.yaml` file:

[source,yaml]
----
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.17.1
        ports:
        - containerPort: 80
----

Apply the deployment:

[source,bash]
----
kubectl apply -f deployment.yaml
----

### Step 2: Verify the Deployment

Check the pods:

[source,bash]
----
kubectl get pods
----

You should see three pods running.

### Step 3: Identify the Disadvantages of Manual Deployment

* Lack of version control for Kubernetes resources.
* Difficulty in managing multiple environments (e.g., dev, test, prod).
* No templating for reusability.

### Step 4: Create the Same Deployment Using Helm

Create a Helm chart:

[source,bash]
----
helm create mychart
----

Modify the `values.yaml`:

[source,yaml]
----
replicaCount: 3
image:
  repository: nginx
  tag: "1.17.1"
  pullPolicy: IfNotPresent
service:
  type: ClusterIP
  port: 80
----

Install the chart:

[source,bash]
----
helm install nginx-chart ./mychart
----

### Step 5: Verify the Helm Deployment

Check the pods:

[source,bash]
----
kubectl get pods
----

### Conclusion

Using Helm simplifies deployment, enables version control, and offers templating for reusability.

== Lab 2: Helm Hooks

### Objectives

* Understand Helm hooks and their use cases.
* Implement Helm hooks in a real-world scenario.

### Step 1: Create a Hook in a Helm Chart

Modify the `templates/hooks.yaml` file in your Helm chart:

[source,yaml]
----
apiVersion: batch/v1
kind: Job
metadata:
  name: "{{ .Release.Name }}-hook"
  annotations:
    "helm.sh/hook": pre-install
spec:
  template:
    spec:
      containers:
      - name: hook-container
        image: busybox
        command: ['sh', '-c', 'echo Hello, Helm Hooks! && sleep 5']
      restartPolicy: Never
----

### Step 2: Install the Helm Chart

[source,bash]
----
helm install hook-chart ./mychart
----

### Step 3: Verify the Hook Execution

Check the jobs:

[source,bash]
----
kubectl get jobs
----

You should see a job corresponding to the hook.

### Conclusion

Helm hooks allow you to perform custom actions at different points in a release lifecycle.

== Lab 3: Subcharts and Dependencies Management in Helm

### Objectives

* Learn how to manage dependencies using Helm subcharts.
* Implement subcharts in a Helm chart.

### Step 1: Create a Parent Chart

[source,bash]
----
helm create parentchart
----

### Step 2: Add a Subchart

Create a subchart in `charts/`:

[source,bash]
----
helm create subchart
mv subchart parentchart/charts/
----

### Step 3: Define Dependencies in `requirements.yaml`

Edit the `requirements.yaml`:

[source,yaml]
----
dependencies:
  - name: subchart
    version: 0.1.0
    repository: "file://charts/subchart"
----

### Step 4: Install the Parent Chart

[source,bash]
----
helm dependency update
helm install parent-chart ./parentchart
----

### Conclusion

Subcharts and dependencies help manage complex applications by breaking them into manageable components.

== Lab 4: ArtifactHub - Customizing an Existing Template

### Objectives

* Learn how to find and customize a Helm chart from ArtifactHub.

### Step 1: Find a Chart on ArtifactHub

Visit ArtifactHub and find a chart.

### Step 2: Download the Chart

[source,bash]
----
helm pull stable/nginx
tar -xvf nginx-*.tgz
cd nginx
----

### Step 3: Customize the Chart

Edit the `values.yaml`:

[source,yaml]
----
replicaCount: 5
image:
  repository: custom-nginx
----

### Step 4: Install the Customized Chart

[source,bash]
----
helm install custom-nginx .
----

### Conclusion

ArtifactHub offers a rich repository of Helm charts, which you can customize to suit your needs.

== Lab 5: Kubernetes Monitoring with Prometheus and Grafana Using Helm

### Objectives

* Deploy Prometheus and Grafana using Helm.
* Set up monitoring for a Kubernetes cluster.

### Step 1: Add the Helm Repository

[source,bash]
----
helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
helm repo update
----

### Step 2: Install Prometheus

[source,bash]
----
helm install prometheus prometheus-community/kube-prometheus-stack
----

### Step 3: Install Grafana

[source,bash]
----
helm install grafana prometheus-community/grafana
----

### Step 4: Access Grafana Dashboard

Forward the port:

[source,bash]
----
kubectl port-forward svc/grafana 3000:80
----

### Conclusion

Monitoring a Kubernetes cluster with Prometheus and Grafana provides valuable insights into your applications.

== Lab 6: Deploying and Using a Kubernetes Operator with Helm

### Objectives

* Understand what a Kubernetes Operator is and why it's useful.
* Learn how to deploy a Kubernetes Operator using Helm.

### Step 1: Add the Operator Lifecycle Manager (OLM) Helm Repository

[source,bash]
----
helm repo add operator-framework https://operator-framework.github.io/community-operators
helm repo update
----

### Step 2: Install the Operator Lifecycle Manager (OLM)

[source,bash]
----
helm install olm operator-framework/olm --namespace operators --create-namespace
----

### Step 3: Deploy a Sample Operator

[source,bash]
----
helm install etcd-operator operator-framework/community-operators --namespace operators
----

### Step 4: Create a Custom Resource for the Operator

[source,yaml]
----
apiVersion: etcd.database.coreos.com/v1beta2
kind: EtcdCluster
metadata:
  name: example-etcd-cluster
  namespace: operators
spec:
  size: 3
  version: "3.2.13"
----

Apply the resource:

[source,bash]
----
kubectl apply -f etcd-cluster.yaml
----

### Step 5: Verify the Deployment

[source,bash]
----
kubectl get pods -n operators
----

### Step 6: Test the Operator's Capabilities

Scale the etcd cluster:

[source,yaml]
----
spec:
  size: 5
----

Apply the changes:

[source,bash]
----
kubectl apply -f etcd-cluster.yaml
----

### Step 7: Clean Up

[source,bash]
----
kubectl delete -f etcd-cluster.yaml
helm uninstall etcd-operator --namespace operators
helm uninstall olm --namespace operators
----

### Conclusion

Kubernetes Operators simplify the management of complex applications by automating operational tasks.

== Lab 7: Helm Template Rendering and Debugging

### Objectives

* Understand how Helm templates are rendered.
* Learn how to debug Helm templates using the `helm template` and `helm lint` commands.

### Step 1: Render Helm Templates

Render the templates locally without deploying:

[source,bash]
----
helm template mychart ./mychart
----

### Step 2: Debug Templates with `helm lint`

Use the `helm lint` command to catch template errors:

[source,bash]
----
helm lint ./mychart
----

### Step 3: Fix Identified Errors

If there are any errors, fix them in the template files and re-run the `helm lint` command until it passes.

### Conclusion

Rendering and debugging Helm templates locally ensures that your Helm chart is error-free before deploying to your cluster.

== Lab 8: Managing Helm Releases

### Objectives

* Learn how to manage Helm releases, including upgrades, rollbacks, and uninstalls.

### Step 1: Install an Initial Release

[source,bash]
----
helm install my-release ./mychart
----

### Step 2: Upgrade the Release

Modify `values.yaml` and upgrade the release:

[source,bash]
----
helm upgrade my-release ./mychart
----

### Step 3: Rollback the Release

If the upgrade fails or has issues, roll back to a previous version:

[source,bash]
----
helm rollback my-release 1
----

### Step 4: Uninstall the Release

Uninstall the Helm release:

[source,bash]
----
helm uninstall my-release
----

### Conclusion

Helm's powerful release management capabilities make it easy to manage your application's lifecycle.

== Lab 9: Helm Chart Testing

### Objectives

* Understand how to write and run tests in a Helm chart.

### Step 1: Create a Test File

Add a test file to the `templates/` directory:

[source,yaml]
----
apiVersion: v1
kind: Pod
metadata:
  name: "{{ .Release.Name }}-test"
  annotations:
    "helm.sh/hook": test
spec:
  containers:
  - name: curl
    image: appropriate/curl
    command: ['curl']
    args: ['{{ .Release.Name }}-service']
----

### Step 2: Run the Test

Run the Helm test:

[source,bash]
----
helm test my-release
----

### Step 3: Verify the Test Results

Check the test results:

[source,bash]
----
kubectl get pods | grep test
----

### Conclusion

Helm chart testing ensures that your deployments are functioning as expected.

== Lab 10: Automating Helm Releases with CI/CD

### Objectives

* Learn how to integrate Helm with CI/CD pipelines for automated releases.

### Step 1: Set Up a CI/CD Pipeline

Use GitHub Actions, GitLab CI, or Jenkins to create a CI/CD pipeline.

### Step 2: Write a CI/CD Script for Helm

Create a pipeline script that installs, upgrades, and tests Helm charts:

[source,yaml]
----
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
    - name: Check out code
      uses: actions/checkout@v2
    - name: Set up Helm
      run: curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
    - name: Install Helm chart
      run: helm upgrade --install my-release ./mychart
    - name: Test Helm chart
      run: helm test my-release
----

### Step 3: Run the Pipeline

Commit and push your changes to trigger the pipeline.

### Conclusion

Integrating Helm with CI/CD pipelines automates your deployment process, ensuring consistency and reliability.

== Lab 11: Using Helm with Helmfile for Multi-Environment Management

### Objectives

* Learn how to use Helmfile to manage Helm charts across multiple environments.

### Step 1: Install Helmfile

Install Helmfile on your local machine:

[source,bash]
----
brew install helmfile
----

### Step 2: Create a Helmfile Configuration

Create a `helmfile.yaml` file:

[source,yaml]
----
repositories:
  - name: stable
    url: https://charts.helm.sh/stable

releases:
  - name: my-release
    namespace: default
    chart: stable/nginx
    values:
      - values.yaml
    environments:
      dev:
        values:
          - values-dev.yaml
      prod:
        values:
          - values-prod.yaml
----

### Step 3: Deploy to Different Environments

Deploy to the development environment:

[source,bash]
----
helmfile -e dev apply
----

Deploy to the production environment:

[source,bash]
----
helmfile -e prod apply
----

### Conclusion

Helmfile simplifies the management of Helm charts across multiple environments, making your deployment process more efficient.

== Lab 12: Advanced Helm Templating Techniques

### Objectives

* Explore advanced templating techniques in Helm, such as conditional logic, loops, and named templates.

### Step 1: Add Conditional Logic to a Template

Edit a template file to include conditional logic:

[source,yaml]
----
{{- if .Values.enableFeatureX }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: feature-x-config
data:
  config: "enabled"
{{- end }}
----

### Step 2: Add a Loop to a Template

Include a loop to create multiple resources:

[source,yaml]
----
{{- range .Values.services }}
apiVersion: v1
kind: Service
metadata:
  name: {{ .name }}
spec:
  ports:
  - port: {{ .port }}
{{- end }}
----

### Step 3: Create a Named Template

Define and use a named template:

[source,yaml]
----
{{- define "mychart.service" -}}
apiVersion: v1
kind: Service
metadata:
  name: {{ .name }}
spec:
  ports:
  - port: {{ .port }}
{{- end -}}

{{ include "mychart.service" . }}
----

### Conclusion

Advanced templating techniques allow for greater flexibility and reusability in your Helm charts.

